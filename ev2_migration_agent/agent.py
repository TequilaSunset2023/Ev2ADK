from typing import Optional, Dict, Any
from dotenv import load_dotenv

load_dotenv()

import datetime
import os
import subprocess
import json
from zoneinfo import ZoneInfo
from google.adk.tools.agent_tool import AgentTool
from google.adk.tools import ToolContext, FunctionTool
from google.adk.tools import FunctionTool
from google.adk.tools.tool_context import ToolContext
from google.adk.tools.base_tool import BaseTool
from google.adk.agents import LlmAgent, SequentialAgent, LoopAgent, BaseAgent, Agent
from google.adk.agents.callback_context import CallbackContext
from google.adk.agents.readonly_context import ReadonlyContext
from google.adk.models.lite_llm import LiteLlm, LlmResponse
from google.genai.types import Content, Part, FunctionCall, GenerateContentConfig
from google.adk.planners.built_in_planner import BuiltInPlanner
from google.adk.code_executors import BuiltInCodeExecutor
from google.adk.utils import instructions_utils
from pydantic import BaseModel, Field

from ev2_migration_agent.tools.ev2_tools import (
    get_bicep_templates,
    get_bicep_digest,
    get_ev2_migration_settings,
    build_bicep_to_arm
    )
from ev2_migration_agent.tools.common_file_tools import (
    read_file,
    update_file,
    create_file,
    list_directory_contents
)


"""
All States:
source_bicep_file_path_and_resource_type: The path to the source Bicep file provided by the user, abstracted by LLM.
source_bicep_digest: The digest of the Bicep file, including parameters and resources, given by tool.
bicep_for_specific_resource: The Bicep template for a specific resource type based on the all-in-one Bicep file, generated by LLM.
bicep_for_specific_resource_file_path: The file path where the Bicep template for a specific resource type is saved, generated by tool.
arm_template_for_specific_resource: The ARM template for a specific resource type based on bicep_for_specific_resource, generated by tool.
"""



class SourceBicepFilePath(BaseModel):
    path: str = Field(
        description="source bicep file path given by user."
    ),
    target_resource_type: str = Field(
        description="target resource type to generate bicep file for."
    )


source_bicep_file_path_extract_agent = LlmAgent(
    name="source_bicep_file_path_extract_agent",
    model=LiteLlm(model="azure/gpt-4.1"),
    description=(
        "Use tool to extract source bicep file path from user input."
    ),
    instruction=(
        """
        You are a helpful assistant who extract source bicep file path and target resource type from user input.
        Your response should be a valid JSON object with the following format, never start with markdown or code block marks like ```json, just return the JSON object which can be deserialized directly:
        {
            "path": "<path_to_bicep_file>",
            "target_resource_type": "<target_resource_type>"
        }
        """
    ),
    output_key="source_bicep_file_path_and_resource_type",
    output_schema=SourceBicepFilePath
) 

def digest_agent_after_tool_modifier(
    tool: BaseTool, args: Dict[str, Any], tool_context: ToolContext, tool_response: Dict
) -> Optional[Dict]:
    """Inspects/modifies the tool result after execution."""

    tool_name = tool.name
    state = tool_context.state
    if tool_name == 'get_bicep_digest':
        state["source_bicep_digest"] = tool_response
    return None


bicep_digest_extract_agent = LlmAgent(
    name="bicep_digest_extract_agent",
    model=LiteLlm(model="azure/gpt-4.1"),
    description=(
        "Use tool to get digest of user given bicep file."
    ),
    instruction=(
        f"""
        You are a helpful assistant who use tools to extract digest of a Bicep file.
        The bicep file path saved here: {{source_bicep_file_path_and_resource_type.path}}
        Call tool "get_bicep_digest" one time with proper arguments then you can return the result.
        """
    ),
    tools=[
        get_bicep_digest
    ],
    include_contents='none',
    after_tool_callback=digest_agent_after_tool_modifier,
)


def save_bicep_file_of_specific_resource_type(callback_context:CallbackContext) -> Content:
    """Saves the Bicep file content for a specific resource type after the agent has executed."""

    state = callback_context.state
    bicep_content = state.get("bicep_for_specific_resource", None)
    output_path = os.getenv("EV2_TARGET_FOLDER", None)
    if not output_path:
        raise ValueError("Environment variable 'EV2_TARGET_FOLDER' is not set.")
    if not bicep_content:
        raise ValueError("Bicep content is not available in the state.")
    
    # Ensure the output directory exists
    os.makedirs(output_path, exist_ok=True)
    # Construct the output file path
    output_file_path = os.path.join(output_path, "specific_resource.bicep")
    state["bicep_for_specific_resource_file_path"] = output_file_path

    # Write the Bicep content to the file
    with open(output_file_path, "w") as file:
        file.write(bicep_content)
        
    return None


bicep_for_specific_resource_type_agent = LlmAgent(
    name="bicep_for_specific_resource_type_agent",
    model=LiteLlm(model="azure/gpt-4.1"),
    description=(
        "Use tool to create bicep template for a specific resource type based on a all in one bicep file."
    ),
    instruction=(
        """
        You are a helpful assistant who create bicep template for a specific resource type based on a all in one bicep file.
        Call get_bicep_templates based on the source bicep file digest and user target resource type.
        Source bicep file path and target resource type here:
        {{source_bicep_file_path_and_resource_type}}.

        Your response should be file content of bicep file, never start with markdown or code block marks like ```bicep, just return the bicep file content.
        Your response must be a bicep file content that can be saved as a bicep file and referenced directly in Azure bicep build command.

        Here are the source bicep file digest:
        {{source_bicep_digest}}
        """
    ),
    tools=[
        get_bicep_templates,
        get_ev2_migration_settings
    ],
    include_contents='none',
    output_key="bicep_for_specific_resource",
    after_agent_callback=save_bicep_file_of_specific_resource_type
)

generate_arm_template_agent = LlmAgent(
    name="generate_arm_template_agent",
    model=LiteLlm(model="azure/gpt-4.1"),
    description=(
        "Use tool to generate ARM template for a specific resource type based on a all in one bicep file."
    ),
    instruction=(
        f"""
        You are a helpful assistant who generate ARM template for a specific resource type by calling a tool.
        The bicep file path here: {{bicep_for_specific_resource_file_path}}
        Output path is {os.getenv("EV2_TARGET_TEMPLATE_FOLDER", "")}
        The example output file name is like `SQLServer.template.json`.
        
        If the tool build the ARM template successfully, you can just finish your task.
        If the tool fails to build the ARM template, you will need to fix the bicep file content automatically and call the tool again automatically until the tool succeeds.
        """
    ),
    tools=[
        build_bicep_to_arm,
        read_file,
        update_file,
        list_directory_contents
    ],
    include_contents='none',
    output_key="arm_template_for_specific_resource"
)

coding_agent = Agent(
    model=LiteLlm(model="azure/gpt-4.1"),
    name='CodeAgent',
    instruction="""
    You're a specialist in Code Execution
    """,
    code_executor=BuiltInCodeExecutor(),
)

async def build_instruction(
      readonly_context: ReadonlyContext,
  ) -> str:
    return (f"""
        You are a helpful assistant who generate rollout for a specific resource type based on a all in one bicep file.
        Output path is {os.getenv("EV2_TARGET_FOLDER", "")}
        We already have arm template for the specific resource type, you will use it to generate rollout. You can find it here: {os.getenv("EV2_TARGET_TEMPLATE_FOLDER", "")}
        Make sure you use "create_file" tool to generate the service model, rolloutSpec, and create the configs and scopeBindings accordingly.

        """ +
        await instructions_utils.inject_session_state(
            "Source bicep file path and focused resource type: {source_bicep_file_path_and_resource_type}",
            readonly_context,
        ) +
        f"""
        environment should be : {os.getenv("ENVIROMENT", "")}
        subscriptionKey: {os.getenv("SUBSCRIPTION_KEY", "")}
        rolloutName: {os.getenv("ROLLOUT_NAME", "")}
        """ +
"""
To start, you will find in context:
- bicepFile: The ORIGINAL bicep file to be processed.
- resourceNames: The resources from {bicepFile} to be included in the rollout. But only focus on the resource type you are generating rollout for.
- rolloutName: The name for the new rollout. You will use a proper name based on the selected resources. It is the folder and file name for the rollout.
- rolloutPath: The path to the rollout folder, relative to the artifact root folder. It is usually `rollouts/{environment}/{rolloutName}`.
- subscriptionKey: The subscription key (registered before this step by user) wherethe resources will be deployed.
- ev2MigrationSettings: The settings for the Ev2 migration, such as the target folder in the MCP server.

You will infer the configs and scope bindings from the user-provided information and below examples and descriptions.

A rollout defines instances of the bicep templates, thus you have to generate based on both templates and parameters. Parameters can be find in the original bicep file.

Because one resource can be used in multiple rollouts, the parameters used in one rollout should refer to the ScopeBindings.

The parameters are eventually saved in the configs. Then refered by scopeBindings. The scope bindings (variables prefixed and suffixed with `__`) are used in the parameters. This is because we want to use one scopeBindings across multiple environments.

To create a rollout, you will need call "create_file" tool to generate the service model, rolloutSpec, and create the configs and scopeBindings accordingly.

## Output folder structure & file examples

Ev2 root folder is also called "artifact root". Artifact means all the files needed to define the infra and deployment.

The output folder structure should look like this:

```
{ArtifactRoot} (All paths in the files are relative to this folder)
├── configs
│   ├── Common.Prod.json
│   ├── Common.Dev.json
│   ├── Common.Staging.json
│   ├── ResourceConfigfile.Prod.json
│   ├── ResourceConfigfile.Dev.json
│   └── ResourceConfigfile.Staging.json
├── templates
│   ├── KustoCluster.template.json
│   ├── SQLServer.template.json
│   ├── StorageAccount.template.json
│   ├── VirtualNetwork.template.json
|   ├── ManagedIdentity.template.json
│   └── KustoCluster.template.json
├── rollouts
│   ├── Dev
│   │   ├── AllResources
│   │   │   ├── AllResources.rolloutSpec.json
|   │   │   └── AllResources.serviceModel.json
│   │   └── {RolloutName}
│   │       ├── {RolloutName}.rolloutSpec.json
│   │       ├── {RolloutName}.serviceModel.json
|   |       ├── ManagedIdentity1.parameters.json
│   │       ├── ManagedIdentity2.parameters.json
│   |       └── FederatedIdentityCredential.parameters.json
|   └── Other Environments
├── scopeBindings.json
└── version.txt
```

The contextual relations between these files are as follows:
- Config file: Contains a group of configurations. Common is for service level, while ScopeBindingsConfig is for resource level. Configs are separated into sections. Typically sections are for different resources.
  - One template creates more than one resource. Template files, name, and parameters are used to define single resource.
- Template file: Contains the bicep templates and ARM templates (only arm templates are used in Ev2). Each template file is for a specific resource type.
- RolloutSpec file: Contains the orchestration steps for deploying resources. Each rolloutSpec is for a specific set of resources. It refers to the service model and scope bindings.
- ServiceModel file: Contains the metadata and definitions of the resources. It defines how the resources are grouped and managed. It refers to the template files and config files. The scope tags are used to bind the resources to the configurations.
- ScopeBindings file: Contains the bindings for the scope tags. It defines how the resources are bound to the configurations. It is used in the rolloutSpec and serviceModel files.
  - Every binding name, by default, should be prefixed and suffixed with `__` (double underscores) to avoid conflicts with other bindings. For example, `__Environment__`, `__CommonBinding1__`, etc.
- For all the paths in the file, it's relative to the artifact root folder, not the current working directory or the file location, keep that in mind. For example you use `"templatePath": "templates/StorageAccount.template.json"` in the service model, it means the `StorageAccount.template.json` file is in the `templates` folder under the artifact root folder.

Here are the file examples for each type you might need:
- Service identifier: A GUID that uniquely identifies the service, registered in the Service Tree.
- Subscription Key: A string that identifies the subscription where the resources will be deployed.
- Environment: Ev2 uses this to determine which tenant to used/not to use.

Example parameter file:
```json
{
  "$schema": "https://ev2schema.azure.net/schemas/2020-04-01/RegionAgnosticParameterFile.json",
  "contentVersion": "1.0.0",
  "parameters": {
    "Environment": {
      "value": "__Environment__"
    },
    "WebApplicationName": {
      "value": "__WebApplicationName__"
    }
    // ...
  }
}
```

Example rolloutSpec:
```json
{
  "$schema": "https://ev2schema.azure.net/schemas/2020-04-01/RegionAgnosticRolloutSpecification.json",
  "contentVersion": "1.0.0",
  "rolloutMetadata": {
    "serviceModelPath": "Path/To/MyService.serviceModel.json", // All paths are relative to the artifact root folder.
    "scopeBindingsPath": "Path/To/scopeBindings.json",
    "name": "MyServiceRollout",
    "buildSource": {
      "parameters": {
        "versionFile": "version.txt"
      }
    },
    "configuration": {
      "serviceScope": {
        "specPath": "path/to/configs/CommonConfig.json" // ServiceModel file uses this.
      },
      "serviceGroupScope": {
        "specPath": "path/to/configs/ScopeBindingsConfig.json" // Parameters file refered by ServiceModel uses this.
      }
    }
  },
  "orchestratedSteps": [
    {
      "name": "DeployStorageAccount",
      "targetType": "ServiceResourceDefinition",
      "targetName": "StorageAccount",
      "actions": ["deploy"]
    },
    {
      "name": "DeploySqlServer",
      "targetType": "ServiceResourceDefinition",
      "targetName": "SqlServer",
      "actions": ["deploy"],
      "dependsOn": ["DeployStorageAccount"]
    }
    // ...
  ]
}
```

Example serviceModel:
```json
{
  "$schema": "https://ev2schema.azure.net/schemas/2020-04-01/RegionAgnosticServiceModel.json",
  "contentVersion": "1.0.0",
  "serviceMetadata": {
    "displayName": "Contoso Sample Service",
    "serviceIdentifier": "12345678-90ab-cdef-1234-567890abcdef",
    "serviceGroup": "{service_group_prefix}.ServiceGroupName", // naming convention
    "environment": "$config({configSectionName}.environmentName)",
    "TenantId": "some GUID"
  },
  "serviceResourceGroupDefinitions": [
    {
      "name": "SampleResourceGroup",
      "azureResourceGroupName": "$config({configSectionName}.resourceGroupName)",
      "subscriptionKey": "$config({configSectionName}.subscriptionKey)",
      "serviceResourceDefinitions": [
        {
          "name": "ContosoStorageAccount",
          "composedOf": {
            "arm": {
              "templatePath": "path/to/templates/StorageAccount.template.json", // all paths are relative to the artifact root folder.
              "parametersPath": "path/to/params/StorageAccount.parameters.json",
              "deploymentLevel": "ResourceGroup"
            }
          },
          "scopeTags": [
            {
              "name": "StorageAccount"
            }
          ]
        }
        // ...
      ]
    }
  ]
}
```

Example config:
```json
{
  "Settings": {
    "{configSectionName}": {
      "subscriptionKey" : "ContosoProd",
      "resourceGroupName" : "ContosoResourceGroup",
      "environmentName": "Prod"
      // ...
    },
    // more sections can be added here
  }
}
```

Example scopeBindings:
```json
{
  "$schema": "https://ev2schema.azure.net/schemas/2020-01-01/scopeBindings.json",
  "contentVersion": "1.0.0.0",
  "scopeBindings": [
    {
      "scopeTagName": "Common",
      "bindings": [
        {
          "find": "__CommonBinding1__",
          "replaceWith": "$config({configSectionName}.CommonBinding1)" 
        }
      ]
    },
    {
      "scopeTagName": "TagName",
      "bindings": [
        {
          "find": "__Environment__",
          "replaceWith": "$config(another{configSectionName}.Environment)"
        }
      ]
    }
    // more scope bindings can be added here
  ]
}
```
        """)

rollout_generate_agent = LlmAgent(
    name="rollout_generate_agent",
    model=LiteLlm(model="azure/gpt-4.1"),
    description=(
        "Use tool to generate rollout for a specific resource type based on a all in one bicep file."
    ),
    instruction=build_instruction,
    tools=[
        get_ev2_migration_settings,
        read_file,
        update_file,
        create_file,
        list_directory_contents,
        AgentTool(agent=coding_agent)
    ],
    include_contents='none',
)

root_agent = SequentialAgent(
    name="root_agent",
    description=(
        "Agent to migrate bicep to ev2."
    ),
    sub_agents=[
        source_bicep_file_path_extract_agent,
        bicep_digest_extract_agent,
        bicep_for_specific_resource_type_agent,
        generate_arm_template_agent,
        rollout_generate_agent
    ],
)